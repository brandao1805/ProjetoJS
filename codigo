import * as React from 'react'; // Importa todo o namespace React
import { useState, useEffect, useRef, useContext } from 'react'; // Hooks do React usados ao longo do app
import { View, Text, TextInput, TouchableOpacity, Image, StyleSheet, Alert, Vibration, ScrollView } from 'react-native'; // Componentes básicos do React Native
import { Ionicons } from '@expo/vector-icons'; // Ícones Ionicons via Expo
import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context'; // Áreas seguras (notch/bordas)
import { NavigationContainer, useNavigationContainerRef, useIsFocused } from '@react-navigation/native'; // Container de navegação e hooks
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs'; // Navegação por abas
import { createNativeStackNavigator } from '@react-navigation/native-stack'; // Navegação stack nativa
import AsyncStorage from '@react-native-async-storage/async-storage'; // Persistência simples local
import { Audio } from 'expo-av'; // Módulo de áudio do Expo

// -------------------------------------------------------------
//  DADOS (mock local para o trabalho; módulos de áudio no /assets)
// -------------------------------------------------------------
const MUSICAS = [
  {
    id: '1',
    titulo: 'Wonderful',
    artista: 'Ja Rule (feat. R. Kelly & Ashanti)',
    capaUrl: 'https://i.scdn.co/image/ab67616d0000b2737e81fb67084fb59858a43bf2',
    audioModule: require('./assets/wonderful.mp3'),
  },
  {
    id: '2',
    titulo: 'Bokaloka',
    artista:
      'DJ Boy, Kako, Mc Joaozinho VT, Mc Don Juan, Mc Tuto, Mc V7, Mc Vine7, Mc Pê Leal',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/7b8424d36d8d2566a4bc408c1965e4c5/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/track2.mp3'),
  },
  {
    id: '3',
    titulo: 'Vampiro',
    artista: 'Matuê, WIU, Teto',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/c960508dc43237db89609c0b7211987e/500x500.jpg',
    audioModule: require('./assets/track3.mp3'),
  },
  {
    id: '4',
    titulo: 'Wake Up In The Sky',
    artista: 'Gucci Mane, Bruno Mars, Kodak Black',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/93c37fa9c4aa86f5edac9fd0a3ab7b00/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/WakeUpInTheSky.mp3'),
  },
  {
    id: '5',
    titulo: '1 Por Amor 2 Por Dinheiro',
    artista: 'Racionais MCs',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/e04b68c5a1aa7a29128d05e7ff9e3084/500x500.jpg',
    audioModule: require('./assets/1PorAmor2PorDinheiro.mp3'),
  },
  {
    id: '6',
    titulo: 'Beautiful',
    artista: 'Snoop Dogg ft. Pharrell Williams',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/eea35658898e296aa8b5d817827e6aaf/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/Beautiful.mp3'),
  },
  {
    id: '7',
    titulo: 'YOSEMITE',
    artista: 'Travis Scott',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/7df7ac6028591a5622f24cf32a555510/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/YOSEMITE.mp3'),
  },
  {
    id: '8',
    titulo: 'Quero Ser Feliz Também',
    artista: 'Natiruts',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/29427c053a8d0175221738d1546b5335/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/QueroSerFelizTambem.mp3'),
  },
  {
    id: '9',
    titulo: 'Drip Too Hard',
    artista: 'Lil Baby',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/3d845a35fd7849630324107baf07657b/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/DripTooHard.mp3'),
  },
  {
    id: '10',
    titulo: 'Modo Esquece',
    artista: 'MC GP',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/bfe4031a9d5c5ff196aa67b8cdac0cf3/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/ModoEsquece.mp3'),
  },
  {
    id: '11',
    titulo: 'Somebody To Love',
    artista: 'Queen',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/8b8fc5d117f9357b79f0a0a410a170e8/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/SomebodyToLove.mp3'),
  },
  {
    id: '12',
    titulo: 'Flow Espacial',
    artista: 'Matuê, WIU, Teto',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/6a607b99dfcb2dcd32f787ed0e11bf41/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/FlowEspacial.mp3'),
  },
  {
    id: '13',
    titulo: 'Falta Você',
    artista: 'Thiaguinho',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/51fafcf8a809c4f7287c706c0066c862/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/FaltaVoce.mp3'),
  },
  {
    id: '14',
    titulo: 'Window Shopper',
    artista: '50 Cent',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/58ec83e8f74b55096f2115523eb9e7df/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/WindowShopper.mp3'),
  },
  {
    id: '15',
    titulo: 'Eu Sou 157',
    artista: 'Racionais MCs',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/e04b68c5a1aa7a29128d05e7ff9e3084/500x500.jpg',
    audioModule: require('./assets/157.mp3'),
  },
  {
    id: '16',
    titulo: 'Ela Só Quer Se Bronzear',
    artista: 'MC Jvilla, MC Negão Original, MC Marks',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/cafead8dd58fe9e717b6aa6c055d23f1/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/Bronzear.mp3'),
  },
  {
    id: '17',
    titulo: 'Coração Partido',
    artista: 'Grupo Menos é Mais',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/dc8a602909b1cd752aad82af47ce4810/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/Coracao.mp3'),
  },
  {
    id: '18',
    titulo: 'Thats My Way',
    artista: 'Edi Rock, Seu Jorge',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/22608bd63725993ffa4270c1d814b51c/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/EdiRock.mp3'),
  },
  {
    id: '19',
    titulo: 'Naticongo',
    artista: 'Natiruts',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/17c05d1219c67c2b52e935c449db3c10/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/Naticongo.mp3'),
  },
  {
    id: '20',
    titulo: 'So Sick',
    artista: 'Ne-Yo',
    capaUrl:
      'https://cdn-images.dzcdn.net/images/cover/ad97c751643e185a348fb13199c49944/500x500-000000-80-0-0.jpg',
    audioModule: require('./assets/SoSick.mp3'),
  },
];

// alturas e chaves de armazenamento
const TABBAR_HEIGHT = 80; // Altura fixa da TabBar
const CONTROL_MARGIN = 0; // Margem adicional para a barra de controles
const KEY_LIKED = '@liked_songs'; // Chave de AsyncStorage p/ curtidas
const KEY_PLAYLISTS = '@playlists'; // Chave de AsyncStorage p/ playlists

// -------------------------------------------------------------
// AsyncStorage helpers (curtidas e playlists)
// -------------------------------------------------------------
async function loadLiked() { // Recupera array de IDs curtidos do AsyncStorage
  // retorna array de ids curtidos
  const raw = await AsyncStorage.getItem(KEY_LIKED); // Lê como string
  return raw ? JSON.parse(raw) : []; // Converte para array ou retorna []
} // carrega curtida
async function saveLiked(ids) { // Persiste curtidas
  await AsyncStorage.setItem(KEY_LIKED, JSON.stringify(ids)); // Salva como string
}
  // carrega playlist
async function loadPlaylists() { // Recupera playlists do AsyncStorage
  // retorna array de objetos {id, nome, capaUrl, musicIds[]}
  const raw = await AsyncStorage.getItem(KEY_PLAYLISTS); // Lê como string
  return raw ? JSON.parse(raw) : []; // Converte para array
} // salva playlist
async function savePlaylists(arr) { // Persiste playlists
  await AsyncStorage.setItem(KEY_PLAYLISTS, JSON.stringify(arr)); // Salva como string
}

// -------------------------------------------------------------
// Player Context (fonte única de verdade do player)
// -------------------------------------------------------------
const PlayerContext = React.createContext(null); // Cria contexto para estado global do player

function useAudioPlayer() { // Hook encapsulando lógica do áudio
  // ref guarda a instância do som (não re-renderiza)
  const soundRef = useRef(null); // Referência mutável para Audio.Sound

  // estados do player expostos para a UI
  const [playingId, setPlayingId] = useState(null);     // id da faixa atual
  const [isPlaying, setIsPlaying] = useState(false);    // tocando/pausado
  const [positionMillis, setPositionMillis] = useState(0); // posição atual
  const [durationMillis, setDurationMillis] = useState(1); // duração (≠0 p/ evitar divisão por zero)

  // encerra/descarrega a faixa atual (quando troca de música)
  async function stopCurrent() { // Para e descarrega a instância atual
    if (soundRef.current) {
      try {
        await soundRef.current.stopAsync(); // Para a reprodução
        await soundRef.current.unloadAsync(); // Descarrega da memória
      } catch {} // Ignora erros (por segurança)
      soundRef.current = null; // Limpa a ref
    }
  }

  // callback nativo do expo-av para atualizar posição/duração
  function attachStatus(sound) { // Registra callback de status
    sound.setOnPlaybackStatusUpdate((status) => { // Recebe atualizações
      if (!status.isLoaded) return; // Ignora se não carregado
      setPositionMillis(status.positionMillis || 0); // Atualiza posição
      setDurationMillis(status.durationMillis || 1); // Atualiza duração

      // quando chega ao fim, quem decide a próxima é o Provider via fila/índice
      if (status.didJustFinish) setIsPlaying(false); // Marca como parado no fim
    });
  }

  // inicia/pausa/troca reprodução
  async function play(track) { // Lida com play/pause/troca de faixa
    if (!track) return; // Sem track, nada a fazer

    // se for a mesma faixa e está pausada → retomar
    if (playingId === track.id && soundRef.current && !isPlaying) {
      await soundRef.current.playAsync(); // Retoma
      setIsPlaying(true); // Atualiza estado
      return; // Sai
    }

    // se for a mesma faixa e está tocando → pausar
    if (playingId === track.id && isPlaying) {
      await pause(); // Pausa
      return; // Sai
    }

    // troca de faixa: descarrega a anterior e carrega a nova
    await stopCurrent(); // Garante descarregar anterior
    try {
      const { sound } = await Audio.Sound.createAsync(track.audioModule, { // Cria instância do som
        shouldPlay: true, // Inicia tocando
      });
      soundRef.current = sound; // Guarda a instância
      attachStatus(sound); // Registra callback
      setPlayingId(track.id); // Seta ID atual
      setIsPlaying(true); // Marca como tocando
    } catch (e) {
      Alert.alert('Erro', 'Não foi possível reproduzir a música.'); // Feedback de erro
      console.log('Audio error:', e); // Loga erro no console
    }
  }

  async function pause() { // Pausa a reprodução
    if (soundRef.current) {
      await soundRef.current.pauseAsync(); // Pausa
      setIsPlaying(false); // Atualiza estado
    }
  }

  // “seek” para uma porcentagem da faixa (0…1), usado no slider
  async function seekTo(percent) { // Avança/retrocede para %
    if (!soundRef.current) return; // Sem instância, sai
    const pos = percent * durationMillis; // Converte % -> ms
    try {
      await soundRef.current.setPositionAsync(pos); // Aplica posição
    } catch (e) {
      console.log('erro no seek:', e); // Log em caso de falha
    }
  }

  // desmontagem: descarrega áudio
  useEffect(() => { // Efeito de limpeza ao desmontar
    return () => {
      if (soundRef.current) soundRef.current.unloadAsync(); // Descarrega se existir
    };
  }, []); // Executa uma vez

  return { // Expõe API do player
    play,
    pause,
    isPlaying,
    playingId,
    positionMillis,
    durationMillis,
    seekTo,
  };
}

function PlayerProvider({ children }) { // Provider para contexto do player
  // player contém os métodos/estados de áudio (expo-av)
  const player = useAudioPlayer(); // Instancia o hook do player

  // fila e índice corrente (controlam qual faixa está "selecionada")
  const [queue, setQueue] = useState([]); // Fila atual de reprodução
  const [index, setIndex] = useState(0); // Índice da música atual

  // ao abrir o app, inicia com todas as músicas e escolhe uma aleatória
  useEffect(() => { // Efeito inicial
    const idx = Math.floor(Math.random() * MUSICAS.length); // Índice aleatório
    setQueue(MUSICAS);   // fila com todas as faixas
    setIndex(idx);       // índice inicial aleatório
  }, []); // Só na montagem

  // expõe tudo via contexto
  const value = { player, queue, setQueue, index, setIndex }; // Valor do contexto

  return <PlayerContext.Provider value={value}>{children}</PlayerContext.Provider>; // Provider
}

// hook de acesso ao contexto (garante que esteja dentro do provider)
function usePlayerCtx() { // Hook para ler o contexto
  const ctx = useContext(PlayerContext); // Obtém contexto
  if (!ctx) throw new Error('usePlayerCtx precisa estar dentro do PlayerProvider'); // Protege uso
  return ctx; // Retorna contexto
}

// -------------------------------------------------------------
// Barra Agora Tocando (fixa sobre a Tab, usa a fila/índice do contexto)
// -------------------------------------------------------------
function NowPlayingBar({ navigationRef }) { // Barra inferior de controle rápido
  const { player, queue, index, setIndex } = usePlayerCtx(); // Lê estado global

  if (!queue.length) return null; // Sem fila, não rende nada

  const current = queue[index]; // Música corrente
  const isThisPlaying = current && player.playingId === current.id && player.isPlaying; // Verifica se a atual está tocando

  function goToFull() { // Navega para a tela cheia do player
    // leva para tela completa do player
    if (navigationRef?.current) {
      navigationRef.current.navigate('PlayerFull'); // Ação de navegação
    }
  }

  // navega na fila usando o índice global (próxima/anterior)
  function playAt(i) { // Toca a música na posição i da fila
    if (!queue.length) return; // Proteção
    const norm = ((i % queue.length) + queue.length) % queue.length; // normaliza índice (loop)
    setIndex(norm); // Atualiza índice global
    player.play(queue[norm]); // Reproduz faixa normalizada
  }

  return (
    <View pointerEvents="auto"> {/* Contêiner da barra */}
      <TouchableOpacity
        activeOpacity={0.9}
        onPress={goToFull} // Ao tocar, abre player completo
        style={styles.controlBar}
      >
        <View style={styles.nowTopRow}> {/* Linha superior: capa + textos */}
          {current?.capaUrl ? (
            <Image source={{ uri: current.capaUrl }} style={styles.nowThumb} /> // Miniatura da capa
          ) : (
            <View style={styles.nowThumb} /> // Placeholder
          )}

          <View style={{ marginLeft: 8, flex: 1 }}>
            <Text numberOfLines={1} style={styles.nowTitle}>
              {current?.titulo}
            </Text>
            <Text numberOfLines={1} style={styles.nowArtist}>
              {current?.artista}
            </Text>
          </View>
        </View>

        <View style={styles.nowControls}>
          <TouchableOpacity onPress={() => playAt(index - 1)}>
            <Ionicons name="play-skip-back" size={30} color="#fff" />
          </TouchableOpacity>

          <TouchableOpacity
            onPress={() => (isThisPlaying ? player.pause() : playAt(index))}
            style={styles.controlCenterBtn}
          >
            <Ionicons
              name={isThisPlaying ? 'pause' : 'play'}
              size={25}
              color="#0b0f14"
            />
          </TouchableOpacity>

          <TouchableOpacity onPress={() => playAt(index + 1)}>
            <Ionicons name="play-skip-forward" size={30} color="#fff" />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    </View>
  );
}

// -------------------------------------------------------------
// TELAS — Menu/Buscar/Favoritas/Criar/Playlists
// -------------------------------------------------------------
function MenuScreen() { // Tela de menu com cards estáticos
  // layout estático para compor cards por categoria
  return (
    <SafeAreaView style={styles.safe}> {/* Respeita áreas seguras */}
      <ScrollView contentContainerStyle={styles.scrollContent} bounces={false}> {/* Conteúdo rolável */}
        <Text style={styles.title}>SpotiFei</Text>

        <Text style={[styles.title, { fontSize: 18, marginTop: 20 }]}>
          Músicas Brasileiras
        </Text>
        <View style={styles.cardsRow}> {/* Grid de cards */}
          {MUSICAS.filter((m) => m.id === '5' || m.id === '8').map((m) => (
            <View key={m.id} style={styles.card}> {/* Card individual */}
              <Image source={{ uri: m.capaUrl }} style={styles.cardImg} />
              <Text style={styles.cardTitle}>{m.titulo}</Text>
              <Text style={styles.cardArtist}>{m.artista}</Text>
            </View>
          ))}
        </View>

        <Text style={[styles.title, { fontSize: 18, marginTop: 20 }]}>
          Músicas Estrangeiras
        </Text>
        <View style={styles.cardsRow}>
          {MUSICAS.filter((m) => m.id === '4' || m.id === '9').map((m) => (
            <View key={m.id} style={styles.card}>
              <Image source={{ uri: m.capaUrl }} style={styles.cardImg} />
              <Text style={styles.cardTitle}>{m.titulo}</Text>
              <Text style={styles.cardArtist}>{m.artista}</Text>
            </View>
          ))}
        </View>

        <Text style={[styles.title, { fontSize: 18, marginTop: 20 }]}>
          Em Alta
        </Text>
        <View style={styles.cardsRow}>
          {MUSICAS.filter((m) => m.id === '2' || m.id === '10').map((m) => (
            <View key={m.id} style={styles.card}>
              <Image source={{ uri: m.capaUrl }} style={styles.cardImg} />
              <Text style={styles.cardTitle}>{m.titulo}</Text>
              <Text style={styles.cardArtist}>{m.artista}</Text>
            </View>
          ))}
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

// -------------------------------------------------------------
// TELA BUSCAR
// -------------------------------------------------------------

function BuscarScreen() {
  const { player, setQueue, setIndex } = usePlayerCtx(); // Acesso ao player e fila
  const [query, setQuery] = useState(''); // Texto da busca
  const [liked, setLiked] = useState([]); // IDs curtidos

  // carrega curtidas ao montar
  useEffect(() => {
    loadLiked().then(setLiked); // Busca curtidas armazenadas
  }, []);

  // filtro simples
  let filtered = MUSICAS; // Por padrão, todas
  const q = query.trim().toLowerCase(); // Normaliza busca
  if (q) {
    filtered = MUSICAS.filter(
      (m) =>
        m.titulo.toLowerCase().includes(q) ||
        m.artista.toLowerCase().includes(q)
    ); // Filtro por título/artista
  }

  // curtir/descurtir salva no AsyncStorage e vibra
  async function toggleLike(id) { // Alterna curtida
    const exists = liked.includes(id); // Já curtida?
    const next = exists ? liked.filter((x) => x !== id) : [...liked, id]; // Adiciona/remove
    setLiked(next); // Atualiza estado
    await saveLiked(next); // Persiste
    if (!exists) Vibration.vibrate(30); // Feedback tátil
  }

  return (
    <SafeAreaView style={styles.safe}> {/* Área segura */}
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled" // Não fecha teclado ao tocar nos itens
        bounces={false}
      >
        <Text style={styles.title}>Buscar</Text>
        <TextInput
          placeholder="Digite o nome da música..."
          placeholderTextColor="#8ea0b5"
          value={query} // Valor controlado
          onChangeText={setQuery} // Atualiza estado
          style={styles.input} // Estilos
        />

        {filtered.map((item) => { // Lista filtrada
          const likedThis = liked.includes(item.id); // É curtida?
          const isThisPlaying =
            player.playingId === item.id && player.isPlaying; // Está tocando?
          return (
            <View key={item.id} style={styles.row}> {/* Linha da música */}
              <Image source={{ uri: item.capaUrl }} style={styles.cover} /> {/* Capa */}
              <View style={{ flex: 1, marginLeft: 12 }}> {/* Título/artista */}
                <Text style={styles.songTitle}>{item.titulo}</Text>
                <Text style={styles.songArtist}>{item.artista}</Text>
              </View>

              {/* curtir/descurtir */}
              <TouchableOpacity
                onPress={() => toggleLike(item.id)} // Alterna curtida
                style={[styles.tag, likedThis && styles.tagOn]}
              >
                <Ionicons
                  name={likedThis ? 'heart' : 'heart-outline'} // Ícone preenchido/vazado
                  size={18}
                  color={likedThis ? '#00B8D4' : '#c9d1d9'}
                />
              </TouchableOpacity>

              {/* tocar: configura a fila com todas as músicas e define índice atual */}
              <TouchableOpacity
                onPress={() => {
                  const all = MUSICAS; // Fila completa
                  const i = all.findIndex((m) => m.id === item.id); // Posição do item
                  setQueue(all); // Define fila global
                  setIndex(i >= 0 ? i : 0); // Define índice atual
                  isThisPlaying ? player.pause() : player.play(item); // Play/Pause
                }}
                style={styles.playBtn}
              >
                <Text style={styles.playText}>
                  {isThisPlaying ? '❚❚' : '▶'}
                </Text>
              </TouchableOpacity>
            </View>
          );
        })}
      </ScrollView>
    </SafeAreaView>
  );
}

// -------------------------------------------------------------
// TELA FAVORITOS
// -------------------------------------------------------------

function BibliotecaScreen() {
  const { player, setQueue, setIndex } = usePlayerCtx(); // Player/fila
  const [liked, setLiked] = useState([]); // IDs curtidos
  const isFocused = useIsFocused(); // Hook para saber foco da tela

  // sempre que a tela ganhar foco, recarrega as curtidas
  useEffect(() => {
    if (isFocused) loadLiked().then(setLiked); // Recarrega no foco
  }, [isFocused]);

  // lista só com as favoritas
  const likedSongs = MUSICAS.filter((m) => liked.includes(m.id)); // Filtra músicas curtidas

  return (
    <SafeAreaView style={styles.safe}> {/* Área segura */}
      <ScrollView contentContainerStyle={styles.scrollContent} bounces={false}> {/* Lista */}
        <Text style={styles.title}>Favoritas ({likedSongs.length})</Text> {/* Contador */}

        {likedSongs.length === 0 ? (
          <Text style={styles.subtitle}>Nenhuma música curtida.</Text> // Estado vazio
        ) : (
          likedSongs.map((item) => { // Renderiza cada favorita
            const isThisPlaying =
              player.playingId === item.id && player.isPlaying; // Está tocando?

            return (
              <View key={item.id} style={styles.row}> {/* Linha */}
                <Image source={{ uri: item.capaUrl }} style={styles.cover} />
                <View style={{ flex: 1, marginLeft: 12 }}>
                  <Text style={styles.songTitle}>{item.titulo}</Text>
                  <Text style={styles.songArtist}>{item.artista}</Text>
                </View>

                <TouchableOpacity
                  onPress={() => {
                    //  enfileira APENAS as favoritas
                    const queueOnlyFavs = likedSongs; // Fila restrita às curtidas
                    const i = queueOnlyFavs.findIndex((m) => m.id === item.id); // Índice
                    setQueue(queueOnlyFavs); // Define fila global
                    setIndex(i >= 0 ? i : 0); // Atualiza índice
                    isThisPlaying ? player.pause() : player.play(item); // Play/Pause
                  }}
                  style={styles.playBtn}
                >
                  <Text style={styles.playText}>
                    {isThisPlaying ? '❚❚' : '▶'}
                  </Text>
                </TouchableOpacity>
              </View>
            );
          })
        )}
      </ScrollView>
    </SafeAreaView>
  );
}

// -------------------------------------------------------------
// TELA CRIAR PLAYLIST
// -------------------------------------------------------------

function CriarPlaylistScreen() {
  // formulário simples com seleção de músicas e persistência
  const [nome, setNome] = useState(''); // Nome da playlist
  const [playlists, setPlaylists] = useState([]); // Todas playlists existentes
  const [selected, setSelected] = useState({}); // mapa id->boolean (seleção)

  useEffect(() => {
    loadPlaylists().then(setPlaylists); // Carrega playlists salvas
  }, []);

  async function criar() { // Cria e persiste uma nova playlist
    const n = nome.trim(); // Remove espaços
    if (!n) return Alert.alert('Atenção', 'Informe um nome.'); // Validação
    const musicIds = Object.keys(selected).filter((id) => selected[id]); // Coleta IDs selecionados
    const nova = {
      id: String(Date.now()), // ID único (timestamp)
      nome: n, // Nome definido no input
      capaUrl:
        'https://img.freepik.com/vetores-premium/maquete-de-disco-de-vinil-realista-na-capa-do-album-de-musica-em-branco-vazio-isolada-no-fundo-branco-retro-musical-long-play-em-caixa-de-papel-modelo-branco-ilustracao-vetorial-3d_341509-1731.jpg?w=360',
      musicIds, // Músicas da playlist
    };
    const next = [nova, ...playlists]; // Nova lista com a playlist criada no topo
    setPlaylists(next); // Atualiza estado local
    await savePlaylists(next); // Persiste no AsyncStorage
    setNome(''); // Limpa input
    setSelected({}); // Limpa seleção
    Vibration.vibrate(40); // Feedback tátil
    Alert.alert('Playlist criada!', 'A nova playlist foi salva.');
  }

  function toggleSel(id) { // Marca/desmarca música na seleção
    setSelected((p) => ({ ...p, [id]: !p[id] })); // Alterna booleano
  }

  return (
    <SafeAreaView style={styles.safe}> {/* Área segura */}
      <ScrollView
        contentContainerStyle={styles.scrollContentWithFab}
        bounces={false}
      >
        <Text style={styles.title}>Criar Playlist</Text>
        <TextInput
          placeholder="Nome da playlist" // Placeholder
          placeholderTextColor="#8ea0b5" // Cor placeholder
          value={nome} // Valor controlado
          onChangeText={setNome} // Atualiza estado
          style={styles.input} // Estilo
        />

        {MUSICAS.map((m) => { // Lista de músicas para selecionar
          const on = !!selected[m.id]; // Está selecionada?
          return (
            <TouchableOpacity
              key={m.id}
              onPress={() => toggleSel(m.id)} // Alterna seleção
              style={[styles.selectRow, on && styles.selectRowOn]}
            >
              <Image source={{ uri: m.capaUrl }} style={styles.coverSmall} />
              <View style={{ flex: 1, marginLeft: 10 }}>
                <Text style={styles.songTitle}>{m.titulo}</Text>
                <Text style={styles.songArtist}>{m.artista}</Text>
              </View>
              <Text style={[styles.tagText, on && styles.tagTextOn]}>
                {on ? '✓' : '+'} {/* Indicador visual */}
              </Text>
            </TouchableOpacity>
          );
        })}
      </ScrollView>

      {/* botão flutuante de confirmar criação */}
      <TouchableOpacity onPress={criar} style={styles.fab}> {/* FAB de confirmar */}
        <Text style={styles.fabText}>＋</Text>
      </TouchableOpacity>
    </SafeAreaView>
  );
}

// ---------- Navegação interna das Playlists (lista -> detalhes) ----------
const InnerStack = createNativeStackNavigator(); // Stack interno de playlists

// -------------------------------------------------------------
// TELA PLAYLIST ABERTA
// -------------------------------------------------------------

function PlaylistDetalhes({ route }) {
  const { player, setQueue, setIndex } = usePlayerCtx(); // Player/fila
  const [playlist, setPlaylist] = useState(route?.params?.playlist); // Playlist atual
  const [currentIndex, setCurrentIndex] = useState(0); // Índice local de navegação

  // estados de edição (renomear, adicionar/remover)
  const [editingName, setEditingName] = useState(false); // Modo edição do nome
  const [newName, setNewName] = useState(route?.params?.playlist?.nome || ''); // Nome temporário
  const [addingSongs, setAddingSongs] = useState(false); // Modo adicionar músicas
  const [chooseMap, setChooseMap] = useState({}); // Mapa de seleção para adicionar

  // sempre que entrar, recarrega a versão atual da playlist do AsyncStorage
  useEffect(() => {
    (async () => {
      const all = await loadPlaylists(); // Lê todas playlists
      const found = all.find((p) => p.id === route?.params?.playlist?.id); // Encontra a corrente
      if (found) {
        setPlaylist(found); // Atualiza estado
        setNewName(found.nome); // Sincroniza nome em edição
      }
    })();
  }, [route?.params?.playlist?.id]); // Reage à mudança do ID da playlist na rota

  if (!playlist) { // Se não encontrou
    return (
      <SafeAreaView style={styles.safeCenter}> {/* Centro da tela */}
        <Text style={{ color: '#fff' }}>Playlist não encontrada.</Text>
      </SafeAreaView>
    );
  }

  const songs = MUSICAS.filter((m) => (playlist.musicIds || []).includes(m.id)); // Músicas da playlist

  function playAt(idx) { // Reproduz música na posição idx
    if (!songs.length) return; // Proteção
    // normaliza índice para o range da playlist
    const norm = ((idx % songs.length) + songs.length) % songs.length; // Loop circular
    setCurrentIndex(norm); // Atualiza índice local
    setQueue(songs);      // define a fila como as músicas da playlist
    setIndex(norm);       // posiciona na música clicada
    player.play(songs[norm]); // Reproduz
  }

  // persiste alterações da playlist inteira (renomear/add/remove)
  async function persist(updated) { // Salva alterações no AsyncStorage
    const all = await loadPlaylists(); // Lê todas
    const next = all.map((p) => (p.id === updated.id ? updated : p)); // Substitui a atual
    await savePlaylists(next); // Persiste
    setPlaylist(updated); // Atualiza estado
  }

  async function salvarNovoNome() { // Confirma renomeação
    const n = newName.trim(); // Normaliza
    if (!n) return Alert.alert('Atenção', 'Informe um nome.'); // Valida
    const updated = { ...playlist, nome: n }; // Novo objeto
    await persist(updated); // Persiste
    setEditingName(false); // Sai do modo edição
    Vibration.vibrate(20); // Feedback
  }

  async function removerMusica(musicId) { // Remove música da playlist
    const updated = {
      ...playlist,
      musicIds: (playlist.musicIds || []).filter((id) => id !== musicId), // Filtra ID
    };
    await persist(updated); // Persiste
    Vibration.vibrate(25); // Feedback
  }

  function toggleEscolha(id) { // Alterna seleção na tela de adicionar
    setChooseMap((prev) => ({ ...prev, [id]: !prev[id] })); // Toggle
  }

  async function confirmarAdicao() { // Confirma adição de músicas escolhidas
    const toAdd = Object.keys(chooseMap).filter((id) => chooseMap[id]); // Coleta selecionadas
    if (toAdd.length === 0) {
      setAddingSongs(false); // Fecha modo
      setChooseMap({}); // Limpa seleção
      return; // Nada a adicionar
    }
    // garante que não duplica música na playlist
    const setAtual = new Set(playlist.musicIds || []); // Conjunto atual
    toAdd.forEach((id) => setAtual.add(id)); // Adiciona novas
    const updated = { ...playlist, musicIds: Array.from(setAtual) }; // Atualiza
    await persist(updated); // Persiste
    setAddingSongs(false); // Fecha modo
    setChooseMap({}); // Limpa seleção
    Vibration.vibrate(30); // Feedback
  }

  // músicas que ainda não estão na playlist (para tela de adicionar)
  const notInPlaylist = MUSICAS.filter(
    (m) => !(playlist.musicIds || []).includes(m.id)
  ); // Candidatas a adicionar

  return (
    <SafeAreaView style={styles.safe}> {/* Área segura */}
      <ScrollView contentContainerStyle={styles.scrollContent} bounces={false}> {/* Conteúdo */}
        {/* Header com nome + ações (renomear/adicionar) */}
        <View style={styles.plHeader}> {/* Cabeçalho */}
          {editingName ? (
            <View style={styles.renameRow}> {/* Linha de renomear */}
              <TextInput
                value={newName}
                onChangeText={setNewName}
                placeholder="Nome da playlist"
                placeholderTextColor="#8ea0b5"
                style={[styles.input, { flex: 1, marginBottom: 0 }]}
              />
              <TouchableOpacity onPress={salvarNovoNome} style={[styles.actionBtn, { marginLeft: 10 }]}> {/* Salvar */}
                <Text style={styles.actionText}>Salvar</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => { setEditingName(false); setNewName(playlist.nome); }} style={[styles.actionBtnGhost, { marginLeft: 8 }]}> {/* Cancelar */}
                <Text style={styles.actionGhostText}>Cancelar</Text>
              </TouchableOpacity>
            </View>
          ) : (
            <>
              <Text style={styles.title}>Playlist: {playlist.nome}</Text>
              <View style={styles.actionBar}> {/* Botões de ação */}
                <TouchableOpacity onPress={() => setEditingName(true)} style={styles.actionBtn}> {/* Entrar em modo de renomear */}
                  <Ionicons name="pencil" size={14} color="#031015" />
                  <Text style={styles.actionText}>Renomear</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  onPress={() => setAddingSongs(true)}
                  style={[styles.actionBtn, { marginLeft: 10 }]} // Abrir modo adicionar músicas
                >
                  <Ionicons name="add" size={16} color="#031015" />
                  <Text style={styles.actionText}>Adicionar músicas</Text>
                </TouchableOpacity>
              </View>
            </>
          )}
        </View>

        {/* Modo para adicionar novas músicas à playlist */}
        {addingSongs && (
          <View style={styles.addBox}> {/* Box de adição */}
            <Text style={{ color: '#9aa9bc', marginBottom: 8 }}>
              Selecione músicas para adicionar
            </Text>

            {notInPlaylist.length === 0 ? (
              <Text style={styles.subtitle}>Todas as músicas já estão na playlist.</Text>
            ) : (
              notInPlaylist.map((m) => { // Lista de músicas elegíveis
                const on = !!chooseMap[m.id]; // Está selecionada?
                return (
                  <TouchableOpacity
                    key={m.id}
                    onPress={() => toggleEscolha(m.id)} // Alterna seleção
                    style={[styles.selectRow, on && styles.selectRowOn]}
                  >
                    <Image source={{ uri: m.capaUrl }} style={styles.coverSmall} />
                    <View style={{ flex: 1, marginLeft: 10 }}>
                      <Text style={styles.songTitle}>{m.titulo}</Text>
                      <Text style={styles.songArtist}>{m.artista}</Text>
                    </View>
                    <Text style={[styles.tagText, on && styles.tagTextOn]}>
                      {on ? '✓' : '+'}
                    </Text>
                  </TouchableOpacity>
                );
              })
            )}

            <View style={{ flexDirection: 'row', marginTop: 8 }}> {/* Ações confirmar/cancelar */}
              <TouchableOpacity onPress={confirmarAdicao} style={[styles.actionBtn, { marginRight: 10 }]}>
                <Text style={styles.actionText}>Adicionar</Text>
              </TouchableOpacity>
              <TouchableOpacity onPress={() => { setAddingSongs(false); setChooseMap({}); }} style={styles.actionBtnGhost}>
                <Text style={styles.actionGhostText}>Cancelar</Text>
              </TouchableOpacity>
            </View>
          </View>
        )}

        {/* lista de músicas da playlist, com play e excluir */}
        {songs.length === 0 ? (
          <Text style={styles.subtitle}>Nenhuma música nessa playlist.</Text>
        ) : (
          songs.map((item, idx) => { // Renderiza músicas da playlist
            const isThisPlaying =
              player.playingId === item.id && player.isPlaying; // Verifica se tocando
            return (
              <View key={item.id} style={styles.row}> {/* Linha */}
                <Image source={{ uri: item.capaUrl }} style={styles.cover} />
                <View style={{ flex: 1, marginLeft: 12 }}>
                  <Text style={styles.songTitle}>
                    {item.titulo}
                  </Text>
                  <Text style={styles.songArtist}>{item.artista}</Text>
                </View>

                {/* Play da faixa dentro da playlist */}
                <TouchableOpacity
                  onPress={() => {
                    if (isThisPlaying) {
                      player.pause(); // Se já toca, pausa
                    } else {
                      playAt(idx); // Senão, toca a selecionada
                    }
                  }}
                  style={styles.playBtn}
                >
                  <Text style={styles.playText}>
                    {isThisPlaying ? '❚❚' : '▶'}
                  </Text>
                </TouchableOpacity>

                {/* Excluir (com espaçamento do botão de play) */}
                <TouchableOpacity
                  onPress={() => removerMusica(item.id)}
                  style={[styles.dangerBtn, { marginLeft: 14 }]}
                >
                  <Ionicons name="trash-outline" size={16} color="#ff6b81" />
                </TouchableOpacity>
              </View>
            );
          })
        )}
      </ScrollView>
    </SafeAreaView>
  );
}

// -------------------------------------------------------------
// TELA MINHAS PLAYLIST
// -------------------------------------------------------------

function MinhasPlaylistsScreen({ navigation }) { // Lista de playlists do usuário
  const [playlists, setPlaylists] = useState([]); // Estado local de playlists
  const isFocused = useIsFocused(); // Sabe quando a tela está em foco

  // recarrega sempre que esta tela ganhar foco
  useEffect(() => {
    if (isFocused) {
      loadPlaylists().then(setPlaylists); // Recarrega do AsyncStorage
    }
  }, [isFocused]);

  async function excluirPlaylist(id) { // Remove uma playlist
    const next = playlists.filter((p) => p.id !== id); // Filtra
    setPlaylists(next); // Atualiza estado
    await savePlaylists(next); // Persiste
    Vibration.vibrate(30); // Feedback tátil
  }

  return (
    <SafeAreaView style={styles.safe}> {/* Área segura */}
      <ScrollView contentContainerStyle={styles.scrollContent} bounces={false}> {/* Conteúdo */}
        <Text style={styles.title}>Minhas Playlists</Text> {/* Título */}

        {playlists.length === 0 ? (
          <Text style={styles.subtitle}>Nenhuma playlist criada ainda.</Text>
        ) : (
          playlists.map((p) => (
            // toda a "card" é um botão de abrir
            <TouchableOpacity
              key={p.id}
              style={styles.playlistCard}
              activeOpacity={0.85}
              onPress={() => navigation.navigate('Playlist', { playlist: p })} // Abre detalhes
            >
              <Image source={{ uri: p.capaUrl }} style={styles.playlistImg} />

              <View style={{ flex: 1, marginLeft: 10 }}>
                <Text style={styles.cardTitle}>{p.nome}</Text>
                <Text style={styles.muted}>{p.musicIds?.length || 0} música(s)</Text>
              </View>

              {/* Botão de excluir (único botão visível no card) */}
              <TouchableOpacity
                onPress={() => excluirPlaylist(p.id)}
                style={[styles.dangerBtn, { marginLeft: 10 }]}
              >
                <Text style={styles.dangerText}>Excluir</Text>
              </TouchableOpacity>
            </TouchableOpacity>
          ))
        )}
      </ScrollView>
    </SafeAreaView>
  );
}

function PlaylistsStack() {
  return (
    <InnerStack.Navigator screenOptions={{ headerShown: false }}>
      <InnerStack.Screen name="ListaPlaylists" component={MinhasPlaylistsScreen} />
      <InnerStack.Screen name="Playlist" component={PlaylistDetalhes} />
    </InnerStack.Navigator>
  );
}


// -------------------------------------------------------------
// Player Full (tela detalhada: like, barra de progresso e controles)
// -------------------------------------------------------------
function PlayerFull() {
  // Obtém do contexto: player, fila de músicas, índice atual e função para mudar índice
  const { player, queue, index, setIndex } = usePlayerCtx();

  // Estado local para curtidas
  const [liked, setLiked] = useState([]);

  // Obtém margens seguras (iPhone com notch, por ex.)
  const insets = useSafeAreaInsets();

  // Largura da barra de progresso (para cálculo ao clicar nela)
  const [barWidth, setBarWidth] = useState(0);

  // Música atual na fila
  const current = queue[index];

  // Carrega curtidas ao abrir a tela
  useEffect(() => {
    loadLiked().then(setLiked);
  }, []);

  // Caso não tenha música tocando, mostra aviso
  if (!current) {
    return (
      <SafeAreaView style={styles.safeCenter}>
        <Text style={{ color: '#fff' }}>Nenhuma música tocando.</Text>
      </SafeAreaView>
    );
  }

  // Verifica se essa música está curtida
  const isLiked = liked.includes(current.id);

  // Verifica se essa música é a que está tocando e se está tocando mesmo (play/pause)
  const isThisPlaying = player.playingId === current.id && player.isPlaying;

  // Calcula progresso da faixa (0 a 1)
  const progress =
    player.durationMillis > 0
      ? player.positionMillis / player.durationMillis
      : 0;

  // Alterna curtida da música
  async function toggleLike() {
    const exists = liked.includes(current.id);
    const next = exists
      ? liked.filter((x) => x !== current.id)
      : [...liked, current.id];
    setLiked(next);
    await saveLiked(next);
    if (!exists) Vibration.vibrate(25); // vibra ao curtir
  }

  // Toca uma música com base no índice da fila
  function playAt(i) {
    if (!queue.length) return;
    // normaliza para loop (evita estourar índice)
    const norm = ((i % queue.length) + queue.length) % queue.length;
    setIndex(norm);
    player.play(queue[norm]);
  }

  // Formata posição (ms) → mm:ss
  function fmt(ms) {
    const totalSec = Math.floor(ms / 1000);
    const min = Math.floor(totalSec / 60);
    const sec = totalSec % 60;
    return `${min}:${sec < 10 ? '0' + sec : sec}`;
  }

  // Layout visual da tela de player completo
  return (
    <SafeAreaView
      style={{
        flex: 1,
        backgroundColor: '#05070a',
        paddingTop: insets.top + 8,      // espaço para evitar notch
        paddingBottom: insets.bottom + 80,
        paddingHorizontal: 16,
      }}
    >
      <View style={{ alignItems: 'center', marginTop: 16 }}>
        <Image
          source={{ uri: current.capaUrl }}
          style={{
            width: 240,
            height: 240,
            borderRadius: 20,
            backgroundColor: '#222',
          }}
        />
      </View>

      <View
        style={{
          flexDirection: 'row',
          alignItems: 'center',
          marginTop: 24,
        }}
      >
        <View style={{ flex: 1 }}>
          <Text style={{ color: '#fff', fontSize: 20, fontWeight: '700' }}>
            {current.titulo}
          </Text>
          <Text style={{ color: '#c9d1d9', fontSize: 14 }}>
            {current.artista}
          </Text>
        </View>

        <TouchableOpacity onPress={toggleLike} style={{ padding: 8 }}>
          <Text style={{ color: isLiked ? '#00B8D4' : '#fff', fontSize: 26 }}>
            {isLiked ? '♥' : '♡'}
          </Text>
        </TouchableOpacity>
      </View>

      <View style={{ marginTop: 28 }}>
        <View
          style={styles.progressBg}
          onLayout={(e) => setBarWidth(e.nativeEvent.layout.width)} // salva largura da barra
        >
          <View
            style={[
              styles.progressFill,
              { width: `${Math.min(100, Math.max(0, progress * 100))}%` },
            ]}
          />

          <View
            style={[
              styles.progressHandle,
              {
                left: barWidth * progress - 6, // centraliza handle
              },
            ]}
          />

          <TouchableOpacity
            activeOpacity={1}
            style={StyleSheet.absoluteFill}
            onPress={(e) => {
              if (!barWidth) return;
              const x = e.nativeEvent.locationX;
              const pct = x / barWidth;
              player.seekTo(Math.min(1, Math.max(0, pct)));
            }}
          />
        </View>

        <View
          style={{
            flexDirection: 'row',
            justifyContent: 'space-between',
            marginTop: 6,
          }}
        >
          <Text style={{ color: '#8ea0b5', fontSize: 12 }}>
            {fmt(player.positionMillis)}
          </Text>
          <Text style={{ color: '#8ea0b5', fontSize: 12 }}>
            {fmt(player.durationMillis)}
          </Text>
        </View>
      </View>

      <View
        style={{
          flexDirection: 'row',
          justifyContent: 'space-evenly',
          alignItems: 'center',
          marginTop: 40,
        }}
      >
        <TouchableOpacity onPress={() => playAt(index - 1)}>
          <Ionicons name="play-skip-back" size={28} color="#fff" />
        </TouchableOpacity>

        <TouchableOpacity
          onPress={() => (isThisPlaying ? player.pause() : playAt(index))}
          style={{
            width: 70,
            height: 70,
            borderRadius: 35,
            backgroundColor: '#fff',
            alignItems: 'center',
            justifyContent: 'center',
          }}
        >
          <Ionicons
            name={isThisPlaying ? 'pause' : 'play'}
            size={30}
            color="#0b0f14"
          />
        </TouchableOpacity>

        <TouchableOpacity onPress={() => playAt(index + 1)}>
          <Ionicons name="play-skip-forward" size={28} color="#fff" />
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

// -------------------------------------------------------------
// Navegação principal
// -------------------------------------------------------------
const Tab = createBottomTabNavigator();
const RootStack = createNativeStackNavigator();

function Tabs() {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        headerShown: false,
        tabBarStyle: {
          backgroundColor: '#05070a',
          borderTopColor: 'rgba(255,255,255,0.08)',
          height: TABBAR_HEIGHT,
          paddingBottom: 6,
          paddingTop: 4,
        },
        tabBarActiveTintColor: '#00B8D4',
        tabBarInactiveTintColor: '#8ea0b5',
        tabBarLabelStyle: { fontSize: 11, fontWeight: '600' },
        tabBarIcon: ({ color, focused }) => {
          let iconName;
          switch (route.name) {
            case 'Menu': iconName = focused ? 'home' : 'home-outline'; break;
            case 'Buscar': iconName = focused ? 'search' : 'search-outline'; break;
            case 'Favoritas': iconName = focused ? 'heart' : 'heart-outline'; break;
            case 'Criar': iconName = focused ? 'add-circle' : 'add-circle-outline'; break;
            case 'Playlists': iconName = focused ? 'musical-notes' : 'musical-notes-outline'; break;
            default: iconName = 'ellipse-outline';
          }
          return <Ionicons name={iconName} size={22} color={color} />;
        },
      })}
    >
      <Tab.Screen name="Menu" component={MenuScreen} />
      <Tab.Screen name="Buscar" component={BuscarScreen} />
      <Tab.Screen name="Favoritas" component={BibliotecaScreen} />
      <Tab.Screen name="Criar" component={CriarPlaylistScreen} />
      <Tab.Screen name="Playlists" component={PlaylistsStack} />
    </Tab.Navigator>
  );
}


// -------------------------------------------------------------
// App principal
// -------------------------------------------------------------
export default function App() {
  // ref da navegação (usada na NowPlayingBar)
  const navigationRef = useNavigationContainerRef();

  // Configura áudio para tocar no modo silencioso (iOS)
  useEffect(() => {
    (async () => {
      try {
        await Audio.setAudioModeAsync({
          playsInSilentModeIOS: true,
          staysActiveInBackground: false,
        });
      } catch (e) {
        console.log('Erro ao configurar áudio:', e);
      }
    })();
  }, []);

  return (
    <View style={{ flex: 1, backgroundColor: '#05070a' }} pointerEvents="box-none">
      <PlayerProvider>
        <NavigationContainer ref={navigationRef}>
          <RootStack.Navigator screenOptions={{ headerShown: false }}>
            <RootStack.Screen name="MainTabs" component={Tabs} />
            <RootStack.Screen name="PlayerFull" component={PlayerFull} />
          </RootStack.Navigator>
        </NavigationContainer>
        <NowPlayingBar navigationRef={navigationRef} />
      </PlayerProvider>
    </View>
  );
}

// -------------------------------------------------------------
// ESTILOS (tema preto + cinza + ciano #00B8D4)
// -------------------------------------------------------------
const styles = StyleSheet.create({
  // BASES
  safe: {
    flex: 1,
    backgroundColor: '#05070a',
  },
  safeCenter: {
    flex: 1,
    backgroundColor: '#05070a',
    alignItems: 'center',
    justifyContent: 'center',
  },
  scrollContent: {
    flexGrow: 1,
    backgroundColor: '#05070a',
    paddingHorizontal: 16,
    paddingTop: 12,
    paddingBottom: 180,
  },
  scrollContentWithFab: {
    flexGrow: 1,
    backgroundColor: '#05070a',
    paddingHorizontal: 16,
    paddingTop: 12,
    paddingBottom: 220,
  },

  // TEXTOS
  title: {
    color: '#ffffff',
    fontSize: 22,
    fontWeight: '700',
    letterSpacing: 0.2,
    marginBottom: 6,
  },
  subtitle: {
    color: '#9aa9bc',
    fontSize: 14,
  },
  muted: {
    color: '#7e8b9b',
    fontSize: 12,
  },

  // INPUT
  input: {
    backgroundColor: '#0f1620',
    borderColor: '#1f2a38',
    borderWidth: 1,
    borderRadius: 14,
    color: '#fff',
    paddingHorizontal: 14,
    paddingVertical: 10,
    marginTop: 10,
    marginBottom: 12,
    fontSize: 14,
  },

  // LINHAS / LISTAS
  row: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    borderBottomWidth: 0.4,
    borderBottomColor: 'rgba(255,255,255,0.02)',
  },

  // seleção de músicas
  selectRow: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0f1620',
    borderColor: 'rgba(0,184,212,0)',
    borderWidth: 1,
    borderRadius: 14,
    padding: 10,
    marginBottom: 8,
  },
  selectRowOn: {
    backgroundColor: 'rgba(0,184,212,0.12)',
    borderColor: 'rgba(0,184,212,0.6)',
  },

  // IMAGENS
  cover: {
    width: 56,
    height: 56,
    borderRadius: 10,
    backgroundColor: '#131b26',
  },
  coverSmall: {
    width: 44,
    height: 44,
    borderRadius: 10,
    backgroundColor: '#131b26',
  },
  playlistImg: {
    width: 52,
    height: 52,
    borderRadius: 14,
    backgroundColor: '#131b26',
  },
  cardImg: {
    width: '100%',
    height: 110,
    borderRadius: 14,
    marginBottom: 10,
    backgroundColor: '#131b26',
  },

  // TEXTOS DE MÚSICA
  songTitle: {
    color: '#ffffff',
    fontSize: 14,
    fontWeight: '600',
  },
  songArtist: {
    color: '#8f9eb2',
    fontSize: 12,
    marginTop: 2,
  },

  // BOTÕES
  playBtn: {
    backgroundColor: '#00B8D4',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    marginLeft: 8,
    shadowColor: '#00B8D4',
    shadowOpacity: 0.35,
    shadowOffset: { width: 0, height: 1 },
    shadowRadius: 4,
    elevation: 2,
  },
  playText: {
    color: '#031015',
    fontWeight: '700',
    fontSize: 13,
  },

  tag: {
    borderColor: '#2e3d56',
    borderWidth: 1,
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    marginRight: 8,
    backgroundColor: 'rgba(15,22,32,0.4)',
  },
  tagOn: {
    backgroundColor: 'rgba(0,184,212,0.12)',
    borderColor: '#00B8D4',
  },
  tagText: {
    color: '#c9d1d9',
    fontWeight: '700',
  },
  tagTextOn: {
    color: '#00B8D4',
  },

  // CARDS DO MENU
  cardsRow: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 16,
    flexWrap: 'wrap',
  },
  card: {
    width: '47%',
    backgroundColor: '#0f1620',
    borderColor: 'rgba(255,255,255,0.02)',
    borderWidth: 1,
    borderRadius: 18,
    padding: 12,
    marginBottom: 10,
    shadowColor: '#000',
    shadowOpacity: 0.22,
    shadowRadius: 5,
    shadowOffset: { width: 0, height: 2 },
  },
  cardTitle: {
    color: '#ffffff',
    fontWeight: '700',
    fontSize: 13.5,
  },
  cardArtist: {
    color: '#8f9eb2',
    fontSize: 11.5,
    marginTop: 2,
  },

  // PLAYLIST CARDS
  playlistCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#0f1620',
    borderColor: 'rgba(255,255,255,0.025)',
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    marginTop: 10,
  },
  dangerBtn: {
    backgroundColor: 'rgba(182,52,65,0.12)',
    borderColor: 'rgba(182,52,65,0.45)',
    borderWidth: 1,
    paddingHorizontal: 12,
    paddingVertical: 7,
    borderRadius: 10,
  },
  dangerText: {
    color: '#ff6b81',
    fontWeight: '700',
    fontSize: 12,
  },

  // BARRA AGORA TOCANDO (fixa acima da TabBar)
  controlBar: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: TABBAR_HEIGHT + CONTROL_MARGIN,
    backgroundColor: '#05070a',
    borderWidth: 1,
    borderColor: 'rgba(0,184,212,0.05)',
    paddingHorizontal: 12,
    paddingTop: 8,
    paddingBottom: 10,
    minHeight: 80,
    borderRadius: 0,
    shadowColor: '#000',
    shadowOpacity: 0.2,
    shadowRadius: 6,
    shadowOffset: { width: 0, height: 3 },
    elevation: 6,
  },
  nowTopRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  nowThumb: {
    width: 30,
    height: 30,
    borderRadius: 8,
    backgroundColor: '#0b0f14',
  },
  nowTitle: {
    color: '#ffffff',
    fontSize: 13,
    fontWeight: '800',
  },
  nowArtist: {
    color: '#9fb0c6',
    fontSize: 11,
    fontWeight: '500',
    marginTop: 1,
  },
  nowControls: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  controlCenterBtn: {
    width: 42,
    height: 42,
    borderRadius: 21,
    backgroundColor: '#fff',
    alignItems: 'center',
    justifyContent: 'center',
  },

  // FAB (criar playlist)
  fab: {
    position: 'absolute',
    bottom: 120,
    right: 20,
    backgroundColor: '#00B8D4',
    width: 62,
    height: 62,
    borderRadius: 31,
    alignItems: 'center',
    justifyContent: 'center',
    shadowColor: '#00B8D4',
    shadowOpacity: 0.35,
    shadowRadius: 6,
    elevation: 8,
  },
  fabText: {
    color: '#031015',
    fontSize: 32,
    fontWeight: '900',
    lineHeight: 33,
  },

  // PROGRESSO DO PLAYER FULL
  progressBg: {
    height: 10,
    backgroundColor: '#1b2736',
    borderRadius: 999,
    overflow: 'hidden',
  },
  progressFill: {
    height: 10,
    backgroundColor: '#00B8D4',
  },
  progressHandle: {
    position: 'absolute',
    top: -1,
    width: 12,
    height: 12,
    borderRadius: 6,
    backgroundColor: '#fff',
  },

  // Playlist Detalhes: header/ações/edição
  plHeader: {
    marginBottom: 8,
  },
  actionBar: {
    flexDirection: 'row',
    marginTop: 8,
  },
  actionBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#00B8D4',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 10,
  },
  actionText: {
    color: '#031015',
    fontWeight: '700',
    marginLeft: 6,
    fontSize: 12,
  },
  actionBtnGhost: {
    borderWidth: 1,
    borderColor: 'rgba(0,184,212,0.5)',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 10,
    backgroundColor: 'rgba(0,184,212,0.08)',
  },
  actionGhostText: {
    color: '#00B8D4',
    fontWeight: '700',
    fontSize: 12,
  },
  renameRow: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  addBox: {
    backgroundColor: '#0f1620',
    borderColor: 'rgba(255,255,255,0.025)',
    borderWidth: 1,
    borderRadius: 16,
    padding: 12,
    marginBottom: 12,
  },
});
